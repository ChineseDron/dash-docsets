<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <title>Unpack data from binary string</title>
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs"><div class="manualnavbar" style="text-align: center;">
 <div class="prev" style="text-align: left; float: left;"><a href="function.uniqid.html">uniqid</a></div>
 <div class="next" style="text-align: right; float: right;"><a href="function.usleep.html">usleep</a></div>
 <div class="up"><a href="ref.misc.html">Misc. Functions</a></div>
 <div class="home"><a href="index.html">PHP Manual</a></div>
</div><hr /><div id="function.unpack" class="refentry">
 <div class="refnamediv">
  <h1 class="refname">unpack</h1>
  <p class="verinfo">(PHP 4, PHP 5)</p><p class="refpurpose"><span class="refname">unpack</span> &mdash; <span class="dc-title">Unpack data from binary string</span></p>

 </div>
 
 <div class="refsect1 description" id="refsect1-function.unpack-description">
  <h3 class="title">Description</h3>
  <div class="methodsynopsis dc-description">
   <span class="type">array</span> <span class="methodname"><b>unpack</b></span>
    ( <span class="methodparam"><span class="type">string</span> <tt class="parameter">$format</tt></span>
   , <span class="methodparam"><span class="type">string</span> <tt class="parameter">$data</tt></span>
   )</div>

  <p class="para rdfs-comment">
   Unpacks from a binary string into an array according to the given
   <i><tt class="parameter">format</tt></i>. 
  </p>
  <p class="para">
   The unpacked data is stored in an associative array. To
   accomplish this you have to name the different format codes and
   separate them by a slash /. If a repeater argument is present,
   then each of the array keys will have a sequence number behind
   the given name.
  </p>
 </div>


 <div class="refsect1 parameters" id="refsect1-function.unpack-parameters">
  <h3 class="title">Parameters</h3>
  <p class="para">
   <dl>

    <dt>

     <span class="term"><i><tt class="parameter">format</tt></i></span>
     <dd>

      <p class="para">
       See <span class="function"><a href="function.pack.html" class="function">pack()</a></span> for an explanation of the format codes.
      </p>
     </dd>

    </dt>

    <dt>

     <span class="term"><i><tt class="parameter">data</tt></i></span>
     <dd>

      <p class="para">
       The packed data.
      </p>
     </dd>

    </dt>

   </dl>

  </p>
 </div>


 <div class="refsect1 returnvalues" id="refsect1-function.unpack-returnvalues">
  <h3 class="title">Return Values</h3>
  <p class="para">
   Returns an associative array containing unpacked elements of binary
   string.
  </p>
 </div>


 <div class="refsect1 examples" id="refsect1-function.unpack-examples">
  <h3 class="title">Examples</h3>
  <p class="para">
   <div class="example" id="example-3436">
    <p><b>Example #1 <span class="function"><b>unpack()</b></span> example</b></p>
    <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br />$binarydata&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #DD0000">"\x04\x00\xa0\x00"</span><span style="color: #007700">;<br /></span><span style="color: #0000BB">$array&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #0000BB">unpack</span><span style="color: #007700">(</span><span style="color: #DD0000">"cchars/nint"</span><span style="color: #007700">,&nbsp;</span><span style="color: #0000BB">$binarydata</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
    </div>

    <div class="example-contents"><p>
     The resulting array will contain the entries &quot;chars&quot; with value
     <i>4</i> and &quot;int&quot; with <i>160</i>.
    </p></div>
   </div>
  </p>

  <p class="para">
   <div class="example" id="example-3437">
    <p><b>Example #2 <span class="function"><b>unpack()</b></span> example with a repeater</b></p>
    <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br />$binarydata&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #DD0000">"\x04\x00\xa0\x00"</span><span style="color: #007700">;<br /></span><span style="color: #0000BB">$array&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #0000BB">unpack</span><span style="color: #007700">(</span><span style="color: #DD0000">"c2chars/nint"</span><span style="color: #007700">,&nbsp;</span><span style="color: #0000BB">$binarydata</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
     </div>

     <div class="example-contents"><p>
      The resulting array will contain the entries &quot;chars1&quot;,
      &quot;chars2&quot; and &quot;int&quot;.
     </p></div>
    </div>
   </p>
  </div>


 <div class="refsect1 notes" id="refsect1-function.unpack-notes">
  <h3 class="title">Notes</h3>
  <div class="caution"><b class="caution">Caution</b>
   <p class="para">
    Note that PHP internally stores integral values as signed. If you
    unpack a large unsigned long and it is of the same size as PHP
    internally stored values the result will be a negative number
    even though unsigned unpacking was specified.
   </p>
  </div>
  <div class="caution"><b class="caution">Caution</b>
   <p class="para">
    Be aware that if you do not name an element, an empty string is used.
    If you do not name more than one element, this means
    that some data is overwritten as the keys are the same such as in:
   </p>
   <p class="para">
    <div class="example" id="example-3438">
     <p><b>Example #3 <span class="function"><b>unpack()</b></span> example with unnamed keys</b></p>
     <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br />$binarydata&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #DD0000">"\x32\x42\x00\xa0"</span><span style="color: #007700">;<br /></span><span style="color: #0000BB">$array&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #0000BB">unpack</span><span style="color: #007700">(</span><span style="color: #DD0000">"c2/n"</span><span style="color: #007700">,&nbsp;</span><span style="color: #0000BB">$binarydata</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">var_dump</span><span style="color: #007700">(</span><span style="color: #0000BB">$array</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
     </div>

     <div class="example-contents"><p>
      The resulting array will contain the entries &quot;1&quot; with value
      <i>160</i> and &quot;2&quot; with <i>66</i>. The
      first value from the <i>c</i> specifier is 
      overwritten by the first value from the <i>n</i>
      specifier.
     </p></div>
    </div>
   </p>
  </div>
 </div>


 <div class="refsect1 seealso" id="refsect1-function.unpack-seealso">
  <h3 class="title">See Also</h3>
  <p class="para">
   <ul class="simplelist">
    <li class="member"><span class="function"><a href="function.pack.html" class="function" rel="rdfs-seeAlso">pack()</a> - Pack data into binary string</span></li>
   </ul>
  </p>
 </div>


</div><div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="106041""></a>
  <div class="note">
   <strong class="user">rogier</strong>
   <a href="#106041" class="date">05-Oct-2011 07:19</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
be aware of the behavior of your system that PHP resides on.<br />
<br />
On x86, unpack MAY not yield the result you expect for UInt32<br />
<br />
This is due to the internal nature of PHP, being that integers are internally stored as SIGNED!<br />
<br />
For x86 systems, unpack('N', "\xff\xff\xff\xff") results in -1<br />
For (most?) x64 systems, unpack('N', "\xff\xff\xff\xff") results in 4294967295.<br />
<br />
This can be verified by checking the value of PHP_INT_SIZE.<br />
If this value is 4, you have a PHP that internally stores 32-bit.<br />
A value of 8 internally stores 64-bit.<br />
<br />
To work around this 'problem', you can use the following code to avoid problems with unpack.<br />
The code is for big endian order but can easily be adjusted for little endian order (also, similar code works for 64-bit integers):<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">_uint32be</span><span class="keyword">(</span><span class="default">$bin</span><span class="keyword">)<br />
{<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">// $bin is the binary 32-bit BE string that represents the integer<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">if (</span><span class="default">PHP_INT_SIZE </span><span class="keyword">&lt;= </span><span class="default">4</span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; list(,</span><span class="default">$h</span><span class="keyword">,</span><span class="default">$l</span><span class="keyword">) = </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">'n*'</span><span class="keyword">, </span><span class="default">$bin</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return (</span><span class="default">$l </span><span class="keyword">+ (</span><span class="default">$h</span><span class="keyword">*</span><span class="default">0x010000</span><span class="keyword">));<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; else{<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; list(,</span><span class="default">$int</span><span class="keyword">) = </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">'N'</span><span class="keyword">, </span><span class="default">$bin</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">$int</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
}<br />
</span><span class="default">?&gt;<br />
</span><br />
Do note that you *could* also use sprintf('%u', $x) to show the unsigned real value.<br />
Also note that (at least when PHP_INT_SIZE = 4) the result WILL be a float value when the input is larger then 0x7fffffff (just check with gettype);<br />
<br />
Hope this helps people.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="103634""></a>
  <div class="note">
   <strong class="user">David Gero dave at havidave dot com</strong>
   <a href="#103634" class="date">25-Apr-2011 07:50</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
You might find these functions useful:<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">byteStr2byteArray</span><span class="keyword">(</span><span class="default">$s</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">array_slice</span><span class="keyword">(</span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"C*"</span><span class="keyword">, </span><span class="string">"\0"</span><span class="keyword">.</span><span class="default">$s</span><span class="keyword">), </span><span class="default">1</span><span class="keyword">);<br />
}<br />
function </span><span class="default">byteArray2byteStr</span><span class="keyword">(array </span><span class="default">$t</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">call_user_func_array</span><span class="keyword">(</span><span class="default">pack</span><span class="keyword">, </span><span class="default">array_merge</span><span class="keyword">(array(</span><span class="string">"C*"</span><span class="keyword">), </span><span class="default">$t</span><span class="keyword">));<br />
}<br />
function </span><span class="default">lsbStr2ushortArray</span><span class="keyword">(</span><span class="default">$s</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">array_slice</span><span class="keyword">(</span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"v*"</span><span class="keyword">, </span><span class="string">"\0\0"</span><span class="keyword">.</span><span class="default">$s</span><span class="keyword">), </span><span class="default">1</span><span class="keyword">);<br />
}<br />
function </span><span class="default">ushortArray2lsbStr</span><span class="keyword">(array </span><span class="default">$t</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">call_user_func_array</span><span class="keyword">(</span><span class="default">pack</span><span class="keyword">, </span><span class="default">array_merge</span><span class="keyword">(array(</span><span class="string">"v*"</span><span class="keyword">), </span><span class="default">$t</span><span class="keyword">));<br />
}<br />
function </span><span class="default">lsbStr2ulongArray</span><span class="keyword">(</span><span class="default">$s</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">array_slice</span><span class="keyword">(</span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"V*"</span><span class="keyword">, </span><span class="string">"\0\0\0\0"</span><span class="keyword">.</span><span class="default">$s</span><span class="keyword">), </span><span class="default">1</span><span class="keyword">);<br />
}<br />
function </span><span class="default">ulongArray2lsbStr</span><span class="keyword">(array </span><span class="default">$t</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">call_user_func_array</span><span class="keyword">(</span><span class="default">pack</span><span class="keyword">, </span><span class="default">array_merge</span><span class="keyword">(array(</span><span class="string">"V*"</span><span class="keyword">), </span><span class="default">$t</span><span class="keyword">));<br />
}<br />
</span><span class="default">?&gt;<br />
</span><br />
Of course, you can address byte strings as if they're arrays with numerical indexes, but the other functions are helpful.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="101682""></a>
  <div class="note">
   <strong class="user">Anonymous</strong>
   <a href="#101682" class="date">04-Jan-2011 07:51</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Between php version 5.1 and 5.1.3 unpack("H*hex", $data) returned wrong data due to bug <a href="http://bugs.php.net/36148." rel="nofollow" target="_blank">http://bugs.php.net/36148.</a></span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="100548""></a>
  <div class="note">
   <strong class="user">zac at picolink dot net</strong>
   <a href="#100548" class="date">22-Oct-2010 08:33</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
The documentation is clear that an integer read using an unsigned format character will still be stored as a signed integer.&nbsp; The often-cited work-around is to use sprintf('%u', $bigint) to properly display integers with the MSB set.<br />
<br />
In the case where the numeric value is more important than how it's displayed, you can still work with other large integers using intval() to "upgrade" your existing unsigned integers.<br />
<br />
I had a problem comparing 32-bit integers read from files with hard-coded constants (file signatures tend to need this).&nbsp; Here's what I did to avoid converting everything into strings:<br />
<br />
<span class="default">&lt;?php<br />
<br />
$bigint </span><span class="keyword">= </span><span class="default">0x89504E47</span><span class="keyword">;<br />
<br />
</span><span class="default">$packed </span><span class="keyword">= </span><span class="default">pack</span><span class="keyword">(</span><span class="string">'N'</span><span class="keyword">, </span><span class="default">$bigint</span><span class="keyword">);<br />
<br />
list(</span><span class="default">$unpacked</span><span class="keyword">) = </span><span class="default">array_values</span><span class="keyword">(</span><span class="default">unpack</span><span class="keyword">(</span><span class="string">'N'</span><span class="keyword">, </span><span class="default">$packed</span><span class="keyword">));<br />
<br />
</span><span class="comment">//The $bigint remains an unsigned integer.<br />
//Even though their bit-wise values are identical, comparison fails.<br />
<br />
</span><span class="keyword">echo </span><span class="string">'bigint '</span><span class="keyword">,<br />
&nbsp; (</span><span class="default">$bigint </span><span class="keyword">== </span><span class="default">$unpacked </span><span class="keyword">? </span><span class="string">'==' </span><span class="keyword">: </span><span class="string">'!='</span><span class="keyword">),<br />
&nbsp; </span><span class="string">" unpacked\n"</span><span class="keyword">;<br />
<br />
</span><span class="comment">//intval() triggers a re-interpretation of $bigint.<br />
//$bigint is internally compared as a signed integer.<br />
//Since the bit-wise value of $bigint never changes, comparison succeeds.<br />
<br />
</span><span class="keyword">echo </span><span class="string">'intval(bigint) '</span><span class="keyword">,<br />
&nbsp; (</span><span class="default">intval</span><span class="keyword">(</span><span class="default">$bigint</span><span class="keyword">) == </span><span class="default">$unpacked </span><span class="keyword">? </span><span class="string">'==' </span><span class="keyword">: </span><span class="string">'!='</span><span class="keyword">),<br />
&nbsp; </span><span class="string">" unpacked\n"</span><span class="keyword">;<br />
<br />
</span><span class="default">?&gt;<br />
</span><br />
It works, but it's a little backwards.&nbsp; If anyone has any ideas on how to "downgrade" a signed integer into an unsigned integer without using strings, that would be a valuable note to add to the documentation.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="100326""></a>
  <div class="note">
   <strong class="user">Aaron Wells</strong>
   <a href="#100326" class="date">08-Oct-2010 03:06</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Another option for converting binary data into PHP data types, is to use the Zend Framework's Zend_Io_Reader class:<br />
<a href="http://bit.ly/9zAhgz" rel="nofollow" target="_blank">http://bit.ly/9zAhgz</a><br />
<br />
There's also a Zend_Io_Writer class that does the reverse.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="97177""></a>
  <div class="note">
   <strong class="user">norwood at computer dot org</strong>
   <a href="#97177" class="date">06-Apr-2010 02:15</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Reading a text cell from an Excel spreadsheet returned a string with low-order embedded nulls: 0x4100 0x4200 etc. To remove the nulls, used<br />
<br />
<span class="default">&lt;?php<br />
$strWithoutNulls </span><span class="keyword">= </span><span class="default">implode</span><span class="keyword">( </span><span class="string">''</span><span class="keyword">, </span><span class="default">explode</span><span class="keyword">( </span><span class="string">"\0"</span><span class="keyword">, </span><span class="default">$strWithNulls </span><span class="keyword">) );<br />
</span><span class="default">?&gt;<br />
</span><br />
(unpack() didn't seem to help much here; needed chars back to re-constitute the string, not integers.)</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="93714""></a>
  <div class="note">
   <strong class="user">Anonymous</strong>
   <a href="#93714" class="date">23-Sep-2009 08:02</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Functions I found useful when dealing with fixed width file processing, related to unpack/pack functions.<br />
<span class="default">&lt;?php<br />
</span><span class="comment">/**<br />
* funpack<br />
* format: array of key, length pairs<br />
* data: string to unpack<br />
*/<br />
</span><span class="keyword">function </span><span class="default">funpack</span><span class="keyword">(</span><span class="default">$format</span><span class="keyword">, </span><span class="default">$data</span><span class="keyword">){<br />
&nbsp;&nbsp;&nbsp; foreach (</span><span class="default">$format </span><span class="keyword">as </span><span class="default">$key </span><span class="keyword">=&gt; </span><span class="default">$len</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$result</span><span class="keyword">[</span><span class="default">$key</span><span class="keyword">] = </span><span class="default">trim</span><span class="keyword">(</span><span class="default">substr</span><span class="keyword">(</span><span class="default">$data</span><span class="keyword">, </span><span class="default">$pos</span><span class="keyword">, </span><span class="default">$len</span><span class="keyword">));<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$pos</span><span class="keyword">+= </span><span class="default">$len</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">$result</span><span class="keyword">;<br />
}<br />
<br />
</span><span class="comment">/**<br />
* fpack<br />
* format: array of key, length pairs<br />
* data: array of key, value pairs to pack<br />
* pad: padding direction<br />
*/<br />
</span><span class="keyword">function </span><span class="default">fpack</span><span class="keyword">(</span><span class="default">$format</span><span class="keyword">, </span><span class="default">$data</span><span class="keyword">, </span><span class="default">$pad </span><span class="keyword">= </span><span class="default">STR_PAD_RIGHT</span><span class="keyword">){<br />
&nbsp;&nbsp;&nbsp; foreach (</span><span class="default">$format </span><span class="keyword">as </span><span class="default">$key </span><span class="keyword">=&gt; </span><span class="default">$len</span><span class="keyword">){<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$result </span><span class="keyword">.= </span><span class="default">substr</span><span class="keyword">(</span><span class="default">str_pad</span><span class="keyword">(</span><span class="default">$data</span><span class="keyword">[</span><span class="default">$key</span><span class="keyword">], </span><span class="default">$len</span><span class="keyword">, </span><span class="default">$pad</span><span class="keyword">), </span><span class="default">0</span><span class="keyword">, </span><span class="default">$len</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">$result</span><span class="keyword">;<br />
}<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="92344""></a>
  <div class="note">
   <strong class="user">sica at wnet com br</strong>
   <a href="#92344" class="date">20-Jul-2009 12:45</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
The script following is a example how to save more than one values on file separating its with "\r\n" and how to recovering its values.<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="comment">// Save two integer values in a binary file<br />
</span><span class="default">$nomearq </span><span class="keyword">= </span><span class="string">"./teste.bin"</span><span class="keyword">;<br />
</span><span class="default">$valor </span><span class="keyword">= </span><span class="default">123</span><span class="keyword">;<br />
</span><span class="default">$ptrarq </span><span class="keyword">= </span><span class="default">fopen</span><span class="keyword">(</span><span class="default">$nomearq</span><span class="keyword">, </span><span class="string">"wb"</span><span class="keyword">);<br />
</span><span class="default">$valorBin </span><span class="keyword">= </span><span class="default">pack</span><span class="keyword">(</span><span class="string">"L"</span><span class="keyword">,</span><span class="default">$valor</span><span class="keyword">);<br />
echo </span><span class="string">"First value (</span><span class="default">$valor</span><span class="string">) packed with "</span><span class="keyword">;<br />
echo </span><span class="default">fwrite</span><span class="keyword">(</span><span class="default">$ptrarq</span><span class="keyword">, </span><span class="default">$valorBin</span><span class="keyword">).</span><span class="string">" bytes&lt;br&gt;"</span><span class="keyword">;<br />
echo </span><span class="string">"Separator \\r\\n with "</span><span class="keyword">;<br />
echo </span><span class="default">fwrite</span><span class="keyword">(</span><span class="default">$ptrarq</span><span class="keyword">, </span><span class="string">"\r\n"</span><span class="keyword">).</span><span class="string">" bytes&lt;br&gt;"</span><span class="keyword">;<br />
</span><span class="default">$valor </span><span class="keyword">= </span><span class="default">456</span><span class="keyword">;<br />
</span><span class="default">$valorBin </span><span class="keyword">= </span><span class="default">pack</span><span class="keyword">(</span><span class="string">"L"</span><span class="keyword">,</span><span class="default">$valor</span><span class="keyword">);<br />
echo </span><span class="string">"Second value (</span><span class="default">$valor</span><span class="string">) packed with "</span><span class="keyword">;<br />
echo </span><span class="default">fwrite</span><span class="keyword">(</span><span class="default">$ptrarq</span><span class="keyword">, </span><span class="default">$valorBin</span><span class="keyword">).</span><span class="string">" bytes&lt;br&gt;"</span><span class="keyword">;<br />
</span><span class="default">fclose</span><span class="keyword">(</span><span class="default">$ptrarq</span><span class="keyword">);<br />
<br />
</span><span class="comment">// Recover the saved values<br />
</span><span class="default">$ptrarq </span><span class="keyword">= </span><span class="default">fopen</span><span class="keyword">(</span><span class="default">$nomearq</span><span class="keyword">, </span><span class="string">"rb"</span><span class="keyword">);<br />
</span><span class="default">$valorBin </span><span class="keyword">= </span><span class="default">file</span><span class="keyword">(</span><span class="default">$nomearq</span><span class="keyword">,</span><span class="default">filesize</span><span class="keyword">(</span><span class="default">$nomearq</span><span class="keyword">));<br />
echo </span><span class="string">"&lt;br&gt;The reading values is:&lt;br&gt;"</span><span class="keyword">;<br />
foreach(</span><span class="default">$valorBin </span><span class="keyword">as </span><span class="default">$valor</span><span class="keyword">){<br />
&nbsp; </span><span class="default">$valor </span><span class="keyword">= </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"L"</span><span class="keyword">,</span><span class="default">$valor</span><span class="keyword">);<br />
&nbsp; </span><span class="default">print_r</span><span class="keyword">(</span><span class="default">$valor</span><span class="keyword">);<br />
&nbsp; echo </span><span class="string">"&lt;br&gt;"</span><span class="keyword">;<br />
}<br />
</span><span class="default">fclose</span><span class="keyword">(</span><span class="default">$ptrarq</span><span class="keyword">);<br />
</span><span class="default">?&gt;<br />
</span><br />
Results:<br />
First value (123) packed with 4 bytes<br />
Separator \r\n with 2 bytes<br />
Second value (456) packed with 4 bytes<br />
<br />
The reading values is:<br />
Array ( [1] =&gt; 123 ) <br />
Array ( [1] =&gt; 456 )</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="87546""></a>
  <div class="note">
   <strong class="user">jlarsen at fsu dot edu</strong>
   <a href="#87546" class="date">09-Dec-2008 03:40</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
As with perl, the count for hex is number of nybbles or half-bytes, this differs from the other options which count in full bytes.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="83349""></a>
  <div class="note">
   <strong class="user">Nhon</strong>
   <a href="#83349" class="date">21-May-2008 01:42</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
As stated above, "if you unpack a large unsigned long and it is of the same size as PHP internally stored values the result will be a negative number even though unsigned unpacking was specified."<br />
<br />
To restore the original unsigned value, you could do this :<br />
<br />
if ($unpackedVal &lt;0)<br />
{<br />
&nbsp;&nbsp; &nbsp;&nbsp; $unpackedVal += 4294967296;<br />
}<br />
<br />
Hope this helps !<br />
<br />
Cheers</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="82146""></a>
  <div class="note">
   <strong class="user">Anonymous Coward</strong>
   <a href="#82146" class="date">28-Mar-2008 10:52</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Warning: This unpack function makes the array with keys starting at 1 instead of starting at 0.<br />
<br />
For example:<br />
<span class="default">&lt;?php<br />
&nbsp;</span><span class="keyword">function </span><span class="default">read_field</span><span class="keyword">(</span><span class="default">$h</span><span class="keyword">) {<br />
&nbsp; </span><span class="default">$a</span><span class="keyword">=</span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"V"</span><span class="keyword">,</span><span class="default">fread</span><span class="keyword">(</span><span class="default">$h</span><span class="keyword">,</span><span class="default">4</span><span class="keyword">));<br />
&nbsp; return </span><span class="default">fread</span><span class="keyword">(</span><span class="default">$h</span><span class="keyword">,</span><span class="default">$a</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">]);<br />
&nbsp;}<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="80972""></a>
  <div class="note">
   <strong class="user">joe dot nemeth @ palg dot com</strong>
   <a href="#80972" class="date">08-Feb-2008 10:29</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
A simpler solution is to mask the value with 0xffffffff. For instance:<br />
<br />
<span class="default">&lt;?php<br />
$rec </span><span class="keyword">= </span><span class="default">unpack</span><span class="keyword">(<br />
&nbsp; </span><span class="string">"Vvalue/"</span><span class="keyword">.<br />
&nbsp; </span><span class="string">"Vhash32/"</span><span class="keyword">,<br />
&nbsp; </span><span class="default">$recbin</span><span class="keyword">);<br />
</span><span class="default">$rec</span><span class="keyword">[</span><span class="string">'hash32'</span><span class="keyword">] &amp;= </span><span class="default">0xffffffff</span><span class="keyword">;<br />
</span><span class="default">$rec</span><span class="keyword">[</span><span class="string">'value'</span><span class="keyword">] &amp;= </span><span class="default">0xffffffff</span><span class="keyword">;<br />
</span><span class="default">?&gt;<br />
</span><br />
Unlike sprintf(), which converts the value to a string, this preserves the numeric type of the value.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="80914""></a>
  <div class="note">
   <strong class="user">Shawn Kelly</strong>
   <a href="#80914" class="date">06-Feb-2008 12:14</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Above it says this:<br />
<br />
&nbsp; "Note that PHP internally stores integral values as signed. If&nbsp; you unpack a large unsigned long and it is of the same size as PHP internally stored values the result will be a negative number even though unsigned unpacking was specified."<br />
<br />
This happened to me.&nbsp; I wanted to get a big number from a unsigned long, but it kept coming returning a negative.&nbsp; Happened to notice that sprintf('%u',$dta) will take the useless negative and restore it into its large unsigned proper magnitude.<br />
<br />
Hope this saves someone a little time...</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="79020""></a>
  <div class="note">
   <strong class="user">phpclub at rambler dot ru</strong>
   <a href="#79020" class="date">07-Nov-2007 04:28</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Correct substr&nbsp; <br />
<br />
If you are trying to make unpack 'N' work with unsigned long on 64 bit machines, you should take a look to this bug:<br />
<a href="http://bugs.php.net/bug.php?id=40543" rel="nofollow" target="_blank">http://bugs.php.net/bug.php?id=40543</a><br />
<br />
An ugly workaround for me was:<br />
<br />
//Read a 4-byte integer from file<br />
&nbsp;&nbsp; &nbsp;&nbsp; $_r = fread($f,4);<br />
&nbsp;&nbsp; &nbsp;&nbsp; $a=unpack('Ni',$_r);<br />
&nbsp;&nbsp; &nbsp;&nbsp; $b = sprintf("%b", $a['i']); // binary representation<br />
&nbsp;&nbsp; &nbsp;&nbsp; if(strlen($b) == 64){<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $new = substr($b, 32);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $a['i'] = bindec($new);<br />
&nbsp;&nbsp; &nbsp; &nbsp; }</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="77825""></a>
  <div class="note">
   <strong class="user">Carsten Meier</strong>
   <a href="#77825" class="date">14-Sep-2007 06:12</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
The previous code has an error:<br />
$low = $val &amp; 65536;<br />
has to be:<br />
$low = $val &amp; 65535;<br />
Otherwise only bit #16 gets masked an not the lower 16 bit.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="76865""></a>
  <div class="note">
   <strong class="user">ein at anti-logic dot com</strong>
   <a href="#76865" class="date">02-Aug-2007 03:13</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If you need to unpack an unsigned long that's larger than php's limit (2^31-1) and don't mind doing a lot of fiddling, an easy solution is to unpack it as two shorts.<br />
<br />
For example<br />
<br />
<span class="default">&lt;?php<br />
$val </span><span class="keyword">= </span><span class="default">2147483647</span><span class="keyword">; </span><span class="comment">// we can't actually assign a number larger than 2^31-1 in php to an int, but if you're reading it from outside, it's easy to get larger than that.<br />
// split it into two 16 bit words<br />
</span><span class="default">$high</span><span class="keyword">= </span><span class="default">$val</span><span class="keyword">&gt;&gt;</span><span class="default">16</span><span class="keyword">;<br />
</span><span class="default">$low </span><span class="keyword">= </span><span class="default">$val </span><span class="keyword">&amp; </span><span class="default">65536</span><span class="keyword">;<br />
</span><span class="default">$packed</span><span class="keyword">= </span><span class="default">pack</span><span class="keyword">(</span><span class="string">'nn'</span><span class="keyword">,</span><span class="default">$high</span><span class="keyword">,</span><span class="default">$low</span><span class="keyword">);<br />
<br />
</span><span class="comment">// we have a 32bit long packed number assigned to $packed<br />
</span><span class="default">$unpacked </span><span class="keyword">= </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">'nhigh\nlow'</span><span class="keyword">,</span><span class="default">$packed</span><span class="keyword">);<br />
</span><span class="default">$final </span><span class="keyword">= (</span><span class="default">$unpacked</span><span class="keyword">[</span><span class="string">'high'</span><span class="keyword">] &lt;&lt; </span><span class="default">16</span><span class="keyword">) + </span><span class="default">$unpacked</span><span class="keyword">[</span><span class="string">'low'</span><span class="keyword">];<br />
</span><span class="default">?&gt;<br />
</span><br />
Of course this works equally as well as unpacking an externally created unsigned long.<br />
This is most usefull when dealing with bitmasks, where the high and low word don't need to be connected.<br />
<br />
Working with signed values is also possible, but I don't have any code examples to share (no need for them myself).</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="73681""></a>
  <div class="note">
   <strong class="user">elpaso</strong>
   <a href="#73681" class="date">06-Mar-2007 05:38</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If you are trying to make unpack 'N' work with unsigned long on 64 bit machines, you should take a look to this bug:<br />
<a href="http://bugs.php.net/bug.php?id=40543" rel="nofollow" target="_blank">http://bugs.php.net/bug.php?id=40543</a><br />
<br />
An ugly workaround for me was:<br />
<br />
//Read a 4-byte integer from file<br />
&nbsp;&nbsp; &nbsp;&nbsp; $_r = fread($f,4);<br />
&nbsp;&nbsp; &nbsp;&nbsp; $a=unpack('Ni',$_r);<br />
&nbsp;&nbsp; &nbsp;&nbsp; $b = sprintf("%b", $a['i']); // binary representation<br />
&nbsp;&nbsp; &nbsp;&nbsp; if(strlen($b) == 64){<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $new = substr($b, 33);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $a['i'] = bindec($new);<br />
&nbsp;&nbsp; &nbsp; &nbsp; }</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="72591""></a>
  <div class="note">
   <strong class="user">eric dot brison at anakeen dot com</strong>
   <a href="#72591" class="date">25-Jan-2007 02:25</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
An simple function to decode active directory sid<br />
function sid_decode($osid) {<br />
&nbsp; $sid=false;<br />
&nbsp; $u=unpack("H2rev/H2b/nc/Nd/V*e", $osid);<br />
&nbsp; if ($u) {<br />
&nbsp;&nbsp;&nbsp; $n232=pow(2,32);<br />
&nbsp;&nbsp;&nbsp; unset($u["b"]); // unused<br />
&nbsp;&nbsp;&nbsp; $u["c"]= $n232*$u["c"]+$u["d"];<br />
&nbsp;&nbsp;&nbsp; unset($u["d"]);<br />
&nbsp;&nbsp;&nbsp; $sid="S";<br />
&nbsp;&nbsp;&nbsp; foreach ($u as $v) {<br />
&nbsp;&nbsp; &nbsp;&nbsp; if ($v &lt; 0) $v=$n232 + $v;<br />
&nbsp;&nbsp; &nbsp;&nbsp; $sid.= "-".$v;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp; }<br />
&nbsp; return $sid;<br />
}<br />
// example<br />
$osid64="AQUAAAAAAAUVAAAA3DixrE8XmGks/zdlAwIAAA==";<br />
print sid_decode(base64_decode($osid64));<br />
<br />
// display : S-01-5-21-2897295580-1771575119-1698168620-515</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="57612""></a>
  <div class="note">
   <strong class="user">Justin dot SpahrSummers at gmail dot com</strong>
   <a href="#57612" class="date">08-Oct-2005 12:10</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I hadn't realized that if the number after the unpack type was 1 (i.e. "V1page"), that it would behave as if there was no number at all. I had been using a variable and didn't think to watch for this. For instance,<br />
<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="keyword">if (</span><span class="default">$something</span><span class="keyword">)<br />
&nbsp;&nbsp; </span><span class="default">$get </span><span class="keyword">= </span><span class="default">2</span><span class="keyword">;<br />
else<br />
&nbsp;&nbsp; </span><span class="default">$get </span><span class="keyword">= </span><span class="default">1</span><span class="keyword">;<br />
<br />
</span><span class="default">$arr </span><span class="keyword">= </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"V" </span><span class="keyword">. </span><span class="default">$get </span><span class="keyword">. </span><span class="string">"page"</span><span class="keyword">, </span><span class="default">$data</span><span class="keyword">);<br />
<br />
</span><span class="default">?&gt;<br />
</span><br />
Now if $something was FALSE, then $arr will only have one entry named "page". If $something was TRUE, $arr would have "page1" and "page2".</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="54910""></a>
  <div class="note">
   <strong class="user">Cristiano - finatofinato at yahoo dot com dot br</strong>
   <a href="#54910" class="date">19-Jul-2005 06:31</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
STORE FILES IN DATABASE SQL_SERVER<br />
<br />
After days of research, I obtained a solution to my "big-problem" working with php5/sqlserver/iis<br />
<br />
//IN PHP.INI<br />
//Valid range 0 - 2147483647.&nbsp; Default = 4096.<br />
mssql.textsize = 2147483647<br />
<br />
=============&lt;INSERT&gt;==================<br />
$dataString = file_get_contents($_FILES['myfile']['tmp_name']);<br />
$arrData = unpack("H*hex", $dataString);<br />
$ds = "0x".$arrData['hex'];<br />
<br />
$sql = "SET TEXTSIZE 2147483647";<br />
mssql_query($sql, $conn);&nbsp; &nbsp; <br />
$sql = " insert into table (myimage, name, extension) values (".$ds.", '".$name."', '".$extension."') ";<br />
mssql_query($sql, $conn);&nbsp; &nbsp; <br />
=============&lt;/INSERT&gt;==================<br />
<br />
=============&lt;RETRIEVE&gt;==================<br />
$sql = "SET TEXTSIZE 2147483647";<br />
@mssql_query($sql, $conn);&nbsp; &nbsp; <br />
$sql = " select myimage, name, extension from table ";<br />
$rs = @mssql_query($sql, $conn);&nbsp; &nbsp; <br />
<br />
header("Content-Disposition: attachment; filename=".$rs['name'].".".$rs['extension']." ");<br />
echo $rs['myfile'];&nbsp; &nbsp; &nbsp; &nbsp; <br />
<br />
=============&lt;/RETRIEVE&gt;==================<br />
<br />
with apache does not work in some cases (work with txt files, but not work with pdf, .doc....), and you will try to do another solution (the solution is more simple than this of sqlserver)</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="52527""></a>
  <div class="note">
   <strong class="user">info at dreystone dot com</strong>
   <a href="#52527" class="date">04-May-2005 11:31</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Here is my solution to reading a Big-Endian formatted double on an Little-Endian machine.<br />
<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="keyword">function </span><span class="default">ToDouble</span><span class="keyword">(</span><span class="default">$data</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$t </span><span class="keyword">= </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"C*"</span><span class="keyword">, </span><span class="default">pack</span><span class="keyword">(</span><span class="string">"S*"</span><span class="keyword">, </span><span class="default">256</span><span class="keyword">));<br />
&nbsp;&nbsp;&nbsp; if(</span><span class="default">$t</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">] == </span><span class="default">1</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$a </span><span class="keyword">= </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"d*"</span><span class="keyword">, </span><span class="default">$data</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; } else {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$a </span><span class="keyword">= </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"d*"</span><span class="keyword">, </span><span class="default">strrev</span><span class="keyword">(</span><span class="default">$data</span><span class="keyword">));<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; return (double)</span><span class="default">$a</span><span class="keyword">[</span><span class="default">1</span><span class="keyword">];<br />
}<br />
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="52347""></a>
  <div class="note">
   <strong class="user">MagicalTux at FF dot st</strong>
   <a href="#52347" class="date">28-Apr-2005 07:17</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
tomlove at gmail dot com gave a code to easily unpack a string. Here's a variant :<br />
<br />
<span class="default">&lt;?php<br />
$packed </span><span class="keyword">= </span><span class="default">pack</span><span class="keyword">(</span><span class="string">"s*"</span><span class="keyword">, </span><span class="default">123</span><span class="keyword">);<br />
list(</span><span class="default">$unpacked</span><span class="keyword">) = </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"s*0"</span><span class="keyword">, </span><span class="default">$packed</span><span class="keyword">);<br />
</span><span class="default">?&gt;<br />
</span><br />
$unpacked now holds the value 123, not an array.<br />
<br />
unpack() will use numeric keys if you give only numbers (probably same check as is_numeric(), but I didn't test). This can be useful in some cases (like for getting directly your data without using arrays).</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="46725""></a>
  <div class="note">
   <strong class="user">jjfoerch at earthlink dot net</strong>
   <a href="#46725" class="date">21-Oct-2004 04:57</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I had a situation where I had to unpack a file filled with little-endian order double-floats in a way that would work on either little-endian or big-endian machines.&nbsp; PHP doesn't have a formatting code that will change the byte order of doubles, so I wrote this workaround.<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="comment">/*The following code is a workaround for php's unpack function<br />
which does not have the capability of unpacking double precision<br />
floats that were packed in the opposite byte order of the current<br />
machine.<br />
*/<br />
</span><span class="keyword">function </span><span class="default">big_endian_unpack </span><span class="keyword">(</span><span class="default">$format</span><span class="keyword">, </span><span class="default">$data</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$ar </span><span class="keyword">= </span><span class="default">unpack </span><span class="keyword">(</span><span class="default">$format</span><span class="keyword">, </span><span class="default">$data</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$vals </span><span class="keyword">= </span><span class="default">array_values </span><span class="keyword">(</span><span class="default">$ar</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$f </span><span class="keyword">= </span><span class="default">explode </span><span class="keyword">(</span><span class="string">'/'</span><span class="keyword">, </span><span class="default">$format</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$i </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; foreach (</span><span class="default">$f </span><span class="keyword">as </span><span class="default">$f_k </span><span class="keyword">=&gt; </span><span class="default">$f_v</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$repeater </span><span class="keyword">= </span><span class="default">intval </span><span class="keyword">(</span><span class="default">substr </span><span class="keyword">(</span><span class="default">$f_v</span><span class="keyword">, </span><span class="default">1</span><span class="keyword">));<br />
&nbsp;&nbsp;&nbsp; if (</span><span class="default">$repeater </span><span class="keyword">== </span><span class="default">0</span><span class="keyword">) </span><span class="default">$repeater </span><span class="keyword">= </span><span class="default">1</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; if (</span><span class="default">$f_v</span><span class="keyword">{</span><span class="default">1</span><span class="keyword">} == </span><span class="string">'*'</span><span class="keyword">)<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$repeater </span><span class="keyword">= </span><span class="default">count </span><span class="keyword">(</span><span class="default">$ar</span><span class="keyword">) - </span><span class="default">$i</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; if (</span><span class="default">$f_v</span><span class="keyword">{</span><span class="default">0</span><span class="keyword">} != </span><span class="string">'d'</span><span class="keyword">) { </span><span class="default">$i </span><span class="keyword">+= </span><span class="default">$repeater</span><span class="keyword">; continue; }<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$j </span><span class="keyword">= </span><span class="default">$i </span><span class="keyword">+ </span><span class="default">$repeater</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; for (</span><span class="default">$a </span><span class="keyword">= </span><span class="default">$i</span><span class="keyword">; </span><span class="default">$a </span><span class="keyword">&lt; </span><span class="default">$j</span><span class="keyword">; ++</span><span class="default">$a</span><span class="keyword">)<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$p </span><span class="keyword">= </span><span class="default">pack </span><span class="keyword">(</span><span class="string">'d'</span><span class="keyword">,</span><span class="default">$vals</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">]);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$p </span><span class="keyword">= </span><span class="default">strrev </span><span class="keyword">(</span><span class="default">$p</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; list (</span><span class="default">$vals</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">]) = </span><span class="default">array_values </span><span class="keyword">(</span><span class="default">unpack </span><span class="keyword">(</span><span class="string">'d1d'</span><span class="keyword">, </span><span class="default">$p</span><span class="keyword">));<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; ++</span><span class="default">$i</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$a </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; foreach (</span><span class="default">$ar </span><span class="keyword">as </span><span class="default">$ar_k </span><span class="keyword">=&gt; </span><span class="default">$ar_v</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$ar</span><span class="keyword">[</span><span class="default">$ar_k</span><span class="keyword">] = </span><span class="default">$vals</span><span class="keyword">[</span><span class="default">$a</span><span class="keyword">];<br />
&nbsp;&nbsp;&nbsp; ++</span><span class="default">$a</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">$ar</span><span class="keyword">;<br />
}<br />
<br />
list (</span><span class="default">$endiantest</span><span class="keyword">) = </span><span class="default">array_values </span><span class="keyword">(</span><span class="default">unpack </span><span class="keyword">(</span><span class="string">'L1L'</span><span class="keyword">, </span><span class="default">pack </span><span class="keyword">(</span><span class="string">'V'</span><span class="keyword">,</span><span class="default">1</span><span class="keyword">)));<br />
if (</span><span class="default">$endiantest </span><span class="keyword">!= </span><span class="default">1</span><span class="keyword">) </span><span class="default">define </span><span class="keyword">(</span><span class="string">'BIG_ENDIAN_MACHINE'</span><span class="keyword">,</span><span class="default">1</span><span class="keyword">);<br />
if (</span><span class="default">defined </span><span class="keyword">(</span><span class="string">'BIG_ENDIAN_MACHINE'</span><span class="keyword">)) </span><span class="default">$unpack_workaround </span><span class="keyword">= </span><span class="string">'big_endian_unpack'</span><span class="keyword">;<br />
else </span><span class="default">$unpack_workaround </span><span class="keyword">= </span><span class="string">'unpack'</span><span class="keyword">;<br />
</span><span class="default">?&gt;<br />
</span><br />
This workaround is used like this:<br />
<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="keyword">function </span><span class="default">foo</span><span class="keyword">() {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; global </span><span class="default">$unpack_workaround</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$bar </span><span class="keyword">= </span><span class="default">$unpack_workaround</span><span class="keyword">(</span><span class="string">'N7N/V2V/d8d'</span><span class="keyword">,</span><span class="default">$my_data</span><span class="keyword">);<br />
</span><span class="comment">//...<br />
</span><span class="keyword">}<br />
<br />
</span><span class="default">?&gt;<br />
</span><br />
On a little endian machine, $unpack_workaround will simply point to the function unpack.&nbsp; On a big endian machine, it will call the workaround function.<br />
<br />
Note, this solution only works for doubles.&nbsp; In my project I had no need to check for single precision floats.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="45188""></a>
  <div class="note">
   <strong class="user">kennwhite dot nospam at hotmail dot com</strong>
   <a href="#45188" class="date">28-Aug-2004 12:32</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If having a zero-based index is useful/necessary, then instead of:<br />
<br />
$int_list = unpack("s*", $some_binary_data);<br />
<br />
&nbsp;try:<br />
<br />
$int_list = array_merge(unpack("s*", $some_binary_data));<br />
<br />
This will return a 0-based array:<br />
<br />
$int_list[0] = x<br />
$int_list[1] = y<br />
$int_list[2] = z<br />
...<br />
<br />
rather than the default 1-based array returned from unpack when no key is supplied:<br />
<br />
$int_list[1] = x<br />
$int_list[2] = y<br />
$int_list[3] = z<br />
...<br />
<br />
It's not used often, but array_merge() with only one parameter will compress a sequentially-ordered numeric-index, starting with an index of [0].</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="43945""></a>
  <div class="note">
   <strong class="user">Sergio Santana: ssantana at tlaloc dot imta dot mx</strong>
   <a href="#43945" class="date">09-Jul-2004 10:54</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
This is about the last example of my previous post. For the sake of clarity, I'm including again here the example, which expands the one given in the formal documentation:<br />
<br />
&lt;?<br />
&nbsp; $binarydata = "AA\0A";<br />
&nbsp; $array = unpack("c2chars/nint", $binarydata);<br />
&nbsp; foreach ($array as $key =&gt; $value)<br />
&nbsp;&nbsp; &nbsp; echo "\$array[$key] = $value &lt;br&gt;\n";<br />
?&gt;<br />
<br />
This outputs:<br />
<br />
$array[chars1] = 65 <br />
$array[chars2] = 65 <br />
$array[int] = 65 <br />
<br />
Here, we assume that the ascii code for character 'A' is decimal 65.<br />
<br />
Remebering that the format string structure is:<br />
&lt;format-code&gt; [&lt;count&gt;] [&lt;array-key&gt;] [/ ...],<br />
in this example, the format string instructs the function to<br />
&nbsp; 1. ("c2...") Read two chars from the second argument ("AA ...), <br />
&nbsp; 2. (...chars...) Use the array-keys "chars1", and "chars2" for <br />
&nbsp;&nbsp; &nbsp;&nbsp; these two chars read,<br />
&nbsp; 3. (.../n...) Read a short int from the second argument (...\0A"),<br />
&nbsp; 4. (...int") Use the word "int" as the array key for the just read<br />
&nbsp;&nbsp; &nbsp;&nbsp; short.<br />
<br />
I hope this is clearer now,<br />
<br />
Sergio.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="43930""></a>
  <div class="note">
   <strong class="user">Sergio Santana: ssantana at tlaloc dot imta dot mx</strong>
   <a href="#43930" class="date">08-Jul-2004 07:41</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Suppose we need to get some kind of internal representation of an integer, say 65, as a four-byte long. Then we use, something like:<br />
<br />
&lt;?<br />
&nbsp; $i = 65;<br />
&nbsp; $s = pack("l", $i); // long 32 bit, machine byte order<br />
&nbsp; echo strlen($s) . "&lt;br&gt;\n";<br />
&nbsp; echo "***$s***&lt;br&gt;\n";<br />
?&gt;<br />
<br />
The output is:<br />
<br />
X-Powered-By: PHP/4.1.2<br />
Content-type: text/html<br />
<br />
4<br />
***A*** <br />
<br />
(That is the string "A\0\0\0")<br />
<br />
Now we want to go back from string "A\0\0\0" to number 65. In this case we can use:<br />
<br />
&lt;?<br />
&nbsp; $s = "A\0\0\0"; // This string is the bytes representation of number 65<br />
&nbsp; $arr = unpack("l", $s);<br />
&nbsp; foreach ($arr as $key =&gt; $value)<br />
&nbsp;&nbsp; &nbsp; echo "\$arr[$key] = $value&lt;br&gt;\n";<br />
?&gt;<br />
<br />
And this outpus:<br />
X-Powered-By: PHP/4.1.2<br />
Content-type: text/html<br />
<br />
$arr[] = 65<br />
<br />
Let's give the array key a name, say "mykey". In this case, we can use: <br />
<br />
&lt;?<br />
&nbsp; $s = "A\0\0\0"; // This string is the bytes representation of number&nbsp; 65<br />
&nbsp; $arr = unpack("lmykey", $s);<br />
&nbsp; foreach ($arr as $key =&gt; $value)<br />
&nbsp;&nbsp; &nbsp; echo "\$arr[$key] = $value\n";<br />
?&gt;<br />
<br />
An this outpus:<br />
X-Powered-By: PHP/4.1.2<br />
Content-type: text/html<br />
<br />
$arr[mykey] = 65<br />
<br />
The "unpack" documentation is a little bit confusing. I think a more complete example could be:<br />
<br />
&lt;?<br />
&nbsp; $binarydata = "AA\0A";<br />
&nbsp; $array = unpack("c2chars/nint", $binarydata);<br />
&nbsp; foreach ($array as $key =&gt; $value)<br />
&nbsp;&nbsp;&nbsp; echo "\$array[$key] = $value &lt;br&gt;\n";<br />
?&gt;<br />
<br />
whose output is:<br />
<br />
X-Powered-By: PHP/4.1.2<br />
Content-type: text/html<br />
<br />
$array[chars1] = 65 &lt;br&gt;<br />
$array[chars2] = 65 &lt;br&gt;<br />
$array[int] = 65 &lt;br&gt;<br />
<br />
Note that the format string is something like<br />
&lt;format-code&gt; [&lt;count&gt;] [&lt;array-key&gt;] [/ ...]<br />
<br />
I hope this clarifies something<br />
<br />
Sergio</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="31532""></a>
  <div class="note">
   <strong class="user">David Alsbury</strong>
   <a href="#31532" class="date">25-Apr-2003 02:04</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
This is the best example I have found to use unpack.&nbsp; I was finally able to make sense of the documentation afters seeing how they used the function.<br />
<br />
<a href="http://fooassociates.com/phpfer/html/rn45re878.html" rel="nofollow" target="_blank">http://fooassociates.com/phpfer/html/rn45re878.html</a><br />
<br />
Quick Example:<br />
<br />
&lt;?<br />
header("Content-type: text/plain");<br />
<br />
/*<br />
N unsigned long (always 32 bit, big endian byte order)<br />
N = 4 bytes<br />
"N2int_var" will read 8 bytes into 2 vars int_var1 and int_var2<br />
<br />
binary string A324 = decimal 1,093,874,228<br />
binary string &amp;*12 = decimal 640,299,314<br />
<br />
C unsigned char<br />
"Cchar_var" will read 1 byte into char_var<br />
<br />
binary string J = decimal 74<br />
*/<br />
<br />
$assoc_array = unpack("N2int_var/Cchar_var", "A324&amp;*12J");<br />
echo "int_var1 = ", $assoc_array['int_var1'], "\n";<br />
echo "int_var2 = ", $assoc_array['int_var2'], "\n";<br />
echo "char_var = ", $assoc_array['char_var'], "\n";<br />
?&gt;<br />
<br />
Sample Output:<br />
int_var1 = 1093874228<br />
int_var2 = 640299314<br />
char_var = 74</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="22398""></a>
  <div class="note">
   <strong class="user">adam at adeptsoftware dot com</strong>
   <a href="#22398" class="date">16-Jun-2002 09:01</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If you just want to extract a dword/long int from a binary string, the following code works beautifully (intel endian):<br />
<br />
$Number = ord($Buffer{0}) | (ord($Buffer{1})&lt;&lt;8) | (ord($Buffer{2})&lt;&lt;16) | (ord($Buffer{3})&lt;&lt;24);</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="12395""></a>
  <div class="note">
   <strong class="user">DanRichter.at.programmer.dot.net</strong>
   <a href="#12395" class="date">10-Apr-2001 11:26</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
If no key name is given [e.g., unpack('C*',$data)], the keys are simply integers starting at 1, and you have a standard array. (I know of no way to get the array to start at zero.)<br />
<br />
If you use multiple types, you must give a key name for all of them (except optionally one), because the key counter is reset with each slash. For example, in unpack('n2/C*',$data), indices 1 and 2 of the returned array are filled by integers ('n'), then overwritten with characters ('C').</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="4319""></a>
  <div class="note">
   <strong class="user">iredden at redden dot on dot ca</strong>
   <a href="#4319" class="date">11-Mar-2000 04:34</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
<span class="default">&lt;?php<br />
<br />
</span><span class="keyword">function </span><span class="default">parse_pascalstr</span><span class="keyword">(</span><span class="default">$bytes_parsed</span><span class="keyword">, </span><span class="default">$parse_str</span><span class="keyword">) { <br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$parse_info </span><span class="keyword">= </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"x</span><span class="default">$bytes_parsed</span><span class="string">/cstr_len"</span><span class="keyword">, </span><span class="default">$parse_str</span><span class="keyword">);<br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$str_len </span><span class="keyword">= </span><span class="default">$parse_info</span><span class="keyword">[</span><span class="string">"str_len"</span><span class="keyword">]; <br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$bytes_parsed </span><span class="keyword">= </span><span class="default">$bytes_parsed </span><span class="keyword">+ </span><span class="default">1</span><span class="keyword">; <br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$parse_info </span><span class="keyword">= </span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"x</span><span class="default">$bytes_parsed</span><span class="string">/A"</span><span class="keyword">.</span><span class="default">$str_len</span><span class="keyword">.</span><span class="string">"str"</span><span class="keyword">, </span><span class="default">$parse_str</span><span class="keyword">); <br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$str </span><span class="keyword">= </span><span class="default">$parse_info</span><span class="keyword">[</span><span class="string">"str"</span><span class="keyword">]; <br />
&nbsp;&nbsp;&nbsp; </span><span class="default">$bytes_parsed </span><span class="keyword">= </span><span class="default">$bytes_parsed </span><span class="keyword">+ </span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$str</span><span class="keyword">); <br />
<br />
&nbsp;&nbsp;&nbsp; return array(</span><span class="default">$str</span><span class="keyword">, </span><span class="default">$bytes_parsed</span><span class="keyword">); <br />
}<br />
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
<hr /><div class="manualnavbar" style="text-align: center;">
 <div class="prev" style="text-align: left; float: left;"><a href="function.uniqid.html">uniqid</a></div>
 <div class="next" style="text-align: right; float: right;"><a href="function.usleep.html">usleep</a></div>
 <div class="up"><a href="ref.misc.html">Misc. Functions</a></div>
 <div class="home"><a href="index.html">PHP Manual</a></div>
</div></body></html>
