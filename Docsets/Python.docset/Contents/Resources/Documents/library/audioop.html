<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" SYSTEM "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/html; charset=utf-8" http-equiv="Content-Type"/><title>21.1. audioop — Manipulate raw audio data — Python v2.7.2 documentation</title><link href="../_static/default.css" rel="stylesheet" type="text/css"/><link href="../_static/pygments.css" rel="stylesheet" type="text/css"/><script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.7.2',
        COLLAPSE_MODINDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script><script src="../_static/jquery.js" type="text/javascript"></script><script src="../_static/doctools.js" type="text/javascript"></script><link href="../_static/opensearch.xml" rel="search" title="Search within Python v2.7.2 documentation" type="application/opensearchdescription+xml"/><link href="../about.html" rel="author" title="About these documents"/><link href="../copyright.html" rel="copyright" title="Copyright"/><link href="../index.html" rel="top" title="Python v2.7.2 documentation"/><link href="mm.html" rel="up" title="21. Multimedia Services"/><link href="imageop.html" rel="next" title="21.2. imageop — Manipulate raw image data"/><link href="mm.html" rel="prev" title="21. Multimedia Services"/><link href="../_static/py.png" rel="shortcut icon" type="image/png"/><script src="../_static/copybutton.js" type="text/javascript"></script></head><body>
<div class="related">
<h3>Navigation</h3>
<ul>
<li class="right" style="margin-right: 10px">
<a accesskey="I" href="../genindex.html" title="General Index">index</a></li>
<li class="right">
<a accesskey="M" href="../modindex.html" title="Global Module Index">modules</a> |</li>
<li class="right">
<a accesskey="N" href="imageop.html" title="21.2. imageop — Manipulate raw image data">next</a> |</li>
<li class="right">
<a accesskey="P" href="mm.html" title="21. Multimedia Services">previous</a> |</li>
<li><img alt="" src="../_static/py.png" style="vertical-align: middle; margin-top: -1px"/></li>
<li><a href="../index.html">Python v2.7.2 documentation</a> »</li>
<li><a href="index.html">The Python Standard Library</a> »</li>
<li><a accesskey="U" href="mm.html">21. Multimedia Services</a> »</li>
</ul>
</div>
<div class="document">
<div class="documentwrapper">
<div class="bodywrapper">
<div class="body">
<div class="section" id="module-audioop">
<h1>21.1. <tt class="xref docutils literal"><span class="pre">audioop</span></tt> — Manipulate raw audio data<a class="headerlink" href="#module-audioop" title="Permalink to this headline">¶</a></h1>
<p>The <tt class="xref docutils literal"><span class="pre">audioop</span></tt> module contains some useful operations on sound fragments.
It operates on sound fragments consisting of signed integer samples 8, 16 or 32
bits wide, stored in Python strings.  This is the same format as used by the
<a class="reference external" href="al.html#module-al" title="(IRIX) Audio functions on the SGI. (deprecated)"><tt class="xref docutils literal"><span class="pre">al</span></tt></a> and <a class="reference external" href="sunaudio.html#module-sunaudiodev" title="(SunOS) Access to Sun audio hardware. (deprecated)"><tt class="xref docutils literal"><span class="pre">sunaudiodev</span></tt></a> modules.  All scalar items are integers, unless
specified otherwise.</p>
<p id="index-228">This module provides support for a-LAW, u-LAW and Intel/DVI ADPCM encodings.</p>
<p>A few of the more complicated operations only take 16-bit samples, otherwise the
sample size (in bytes) is always a parameter of the operation.</p>
<p>The module defines the following variables and functions:</p>
<dl class="exception">
<a name="//apple_ref/cpp/cl/audioop.error"></a><dt id="audioop.error">
<em class="property">exception </em><tt class="descclassname">audioop.</tt><tt class="descname">error</tt><a class="headerlink" href="#audioop.error" title="Permalink to this definition">¶</a></dt>
<dd>This exception is raised on all errors, such as unknown number of bytes per
sample, etc.</dd></dl>
<dl class="function">
<a name="//apple_ref/cpp/func/audioop.add"></a><dt id="audioop.add">
<tt class="descclassname">audioop.</tt><tt class="descname">add</tt><big>(</big><em>fragment1</em>, <em>fragment2</em>, <em>width</em><big>)</big><a class="headerlink" href="#audioop.add" title="Permalink to this definition">¶</a></dt>
<dd>Return a fragment which is the addition of the two samples passed as parameters.
<em>width</em> is the sample width in bytes, either <tt class="docutils literal"><span class="pre">1</span></tt>, <tt class="docutils literal"><span class="pre">2</span></tt> or <tt class="docutils literal"><span class="pre">4</span></tt>.  Both
fragments should have the same length.</dd></dl>
<dl class="function">
<a name="//apple_ref/cpp/func/audioop.adpcm2lin"></a><dt id="audioop.adpcm2lin">
<tt class="descclassname">audioop.</tt><tt class="descname">adpcm2lin</tt><big>(</big><em>adpcmfragment</em>, <em>width</em>, <em>state</em><big>)</big><a class="headerlink" href="#audioop.adpcm2lin" title="Permalink to this definition">¶</a></dt>
<dd>Decode an Intel/DVI ADPCM coded fragment to a linear fragment.  See the
description of <a class="reference internal" href="#audioop.lin2adpcm" title="audioop.lin2adpcm"><tt class="xref docutils literal"><span class="pre">lin2adpcm()</span></tt></a> for details on ADPCM coding. Return a tuple
<tt class="docutils literal"><span class="pre">(sample,</span> <span class="pre">newstate)</span></tt> where the sample has the width specified in <em>width</em>.</dd></dl>
<dl class="function">
<a name="//apple_ref/cpp/func/audioop.alaw2lin"></a><dt id="audioop.alaw2lin">
<tt class="descclassname">audioop.</tt><tt class="descname">alaw2lin</tt><big>(</big><em>fragment</em>, <em>width</em><big>)</big><a class="headerlink" href="#audioop.alaw2lin" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert sound fragments in a-LAW encoding to linearly encoded sound fragments.
a-LAW encoding always uses 8 bits samples, so <em>width</em> refers only to the sample
width of the output fragment here.</p>
<p class="versionadded">
<span class="versionmodified">New in version 2.5.</span></p>
</dd></dl>
<dl class="function">
<a name="//apple_ref/cpp/func/audioop.avg"></a><dt id="audioop.avg">
<tt class="descclassname">audioop.</tt><tt class="descname">avg</tt><big>(</big><em>fragment</em>, <em>width</em><big>)</big><a class="headerlink" href="#audioop.avg" title="Permalink to this definition">¶</a></dt>
<dd>Return the average over all samples in the fragment.</dd></dl>
<dl class="function">
<a name="//apple_ref/cpp/func/audioop.avgpp"></a><dt id="audioop.avgpp">
<tt class="descclassname">audioop.</tt><tt class="descname">avgpp</tt><big>(</big><em>fragment</em>, <em>width</em><big>)</big><a class="headerlink" href="#audioop.avgpp" title="Permalink to this definition">¶</a></dt>
<dd>Return the average peak-peak value over all samples in the fragment. No
filtering is done, so the usefulness of this routine is questionable.</dd></dl>
<dl class="function">
<a name="//apple_ref/cpp/func/audioop.bias"></a><dt id="audioop.bias">
<tt class="descclassname">audioop.</tt><tt class="descname">bias</tt><big>(</big><em>fragment</em>, <em>width</em>, <em>bias</em><big>)</big><a class="headerlink" href="#audioop.bias" title="Permalink to this definition">¶</a></dt>
<dd>Return a fragment that is the original fragment with a bias added to each
sample.</dd></dl>
<dl class="function">
<a name="//apple_ref/cpp/func/audioop.cross"></a><dt id="audioop.cross">
<tt class="descclassname">audioop.</tt><tt class="descname">cross</tt><big>(</big><em>fragment</em>, <em>width</em><big>)</big><a class="headerlink" href="#audioop.cross" title="Permalink to this definition">¶</a></dt>
<dd>Return the number of zero crossings in the fragment passed as an argument.</dd></dl>
<dl class="function">
<a name="//apple_ref/cpp/func/audioop.findfactor"></a><dt id="audioop.findfactor">
<tt class="descclassname">audioop.</tt><tt class="descname">findfactor</tt><big>(</big><em>fragment</em>, <em>reference</em><big>)</big><a class="headerlink" href="#audioop.findfactor" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a factor <em>F</em> such that <tt class="docutils literal"><span class="pre">rms(add(fragment,</span> <span class="pre">mul(reference,</span> <span class="pre">-F)))</span></tt> is
minimal, i.e., return the factor with which you should multiply <em>reference</em> to
make it match as well as possible to <em>fragment</em>.  The fragments should both
contain 2-byte samples.</p>
<p>The time taken by this routine is proportional to <tt class="docutils literal"><span class="pre">len(fragment)</span></tt>.</p>
</dd></dl>
<dl class="function">
<a name="//apple_ref/cpp/func/audioop.findfit"></a><dt id="audioop.findfit">
<tt class="descclassname">audioop.</tt><tt class="descname">findfit</tt><big>(</big><em>fragment</em>, <em>reference</em><big>)</big><a class="headerlink" href="#audioop.findfit" title="Permalink to this definition">¶</a></dt>
<dd>Try to match <em>reference</em> as well as possible to a portion of <em>fragment</em> (which
should be the longer fragment).  This is (conceptually) done by taking slices
out of <em>fragment</em>, using <a class="reference internal" href="#audioop.findfactor" title="audioop.findfactor"><tt class="xref docutils literal"><span class="pre">findfactor()</span></tt></a> to compute the best match, and
minimizing the result.  The fragments should both contain 2-byte samples.
Return a tuple <tt class="docutils literal"><span class="pre">(offset,</span> <span class="pre">factor)</span></tt> where <em>offset</em> is the (integer) offset into
<em>fragment</em> where the optimal match started and <em>factor</em> is the (floating-point)
factor as per <a class="reference internal" href="#audioop.findfactor" title="audioop.findfactor"><tt class="xref docutils literal"><span class="pre">findfactor()</span></tt></a>.</dd></dl>
<dl class="function">
<a name="//apple_ref/cpp/func/audioop.findmax"></a><dt id="audioop.findmax">
<tt class="descclassname">audioop.</tt><tt class="descname">findmax</tt><big>(</big><em>fragment</em>, <em>length</em><big>)</big><a class="headerlink" href="#audioop.findmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Search <em>fragment</em> for a slice of length <em>length</em> samples (not bytes!) with
maximum energy, i.e., return <em>i</em> for which <tt class="docutils literal"><span class="pre">rms(fragment[i*2:(i+length)*2])</span></tt>
is maximal.  The fragments should both contain 2-byte samples.</p>
<p>The routine takes time proportional to <tt class="docutils literal"><span class="pre">len(fragment)</span></tt>.</p>
</dd></dl>
<dl class="function">
<a name="//apple_ref/cpp/func/audioop.getsample"></a><dt id="audioop.getsample">
<tt class="descclassname">audioop.</tt><tt class="descname">getsample</tt><big>(</big><em>fragment</em>, <em>width</em>, <em>index</em><big>)</big><a class="headerlink" href="#audioop.getsample" title="Permalink to this definition">¶</a></dt>
<dd>Return the value of sample <em>index</em> from the fragment.</dd></dl>
<dl class="function">
<a name="//apple_ref/cpp/func/audioop.lin2adpcm"></a><dt id="audioop.lin2adpcm">
<tt class="descclassname">audioop.</tt><tt class="descname">lin2adpcm</tt><big>(</big><em>fragment</em>, <em>width</em>, <em>state</em><big>)</big><a class="headerlink" href="#audioop.lin2adpcm" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert samples to 4 bit Intel/DVI ADPCM encoding.  ADPCM coding is an adaptive
coding scheme, whereby each 4 bit number is the difference between one sample
and the next, divided by a (varying) step.  The Intel/DVI ADPCM algorithm has
been selected for use by the IMA, so it may well become a standard.</p>
<p><em>state</em> is a tuple containing the state of the coder.  The coder returns a tuple
<tt class="docutils literal"><span class="pre">(adpcmfrag,</span> <span class="pre">newstate)</span></tt>, and the <em>newstate</em> should be passed to the next call
of <a class="reference internal" href="#audioop.lin2adpcm" title="audioop.lin2adpcm"><tt class="xref docutils literal"><span class="pre">lin2adpcm()</span></tt></a>.  In the initial call, <tt class="xref docutils literal"><span class="pre">None</span></tt> can be passed as the state.
<em>adpcmfrag</em> is the ADPCM coded fragment packed 2 4-bit values per byte.</p>
</dd></dl>
<dl class="function">
<a name="//apple_ref/cpp/func/audioop.lin2alaw"></a><dt id="audioop.lin2alaw">
<tt class="descclassname">audioop.</tt><tt class="descname">lin2alaw</tt><big>(</big><em>fragment</em>, <em>width</em><big>)</big><a class="headerlink" href="#audioop.lin2alaw" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert samples in the audio fragment to a-LAW encoding and return this as a
Python string.  a-LAW is an audio encoding format whereby you get a dynamic
range of about 13 bits using only 8 bit samples.  It is used by the Sun audio
hardware, among others.</p>
<p class="versionadded">
<span class="versionmodified">New in version 2.5.</span></p>
</dd></dl>
<dl class="function">
<a name="//apple_ref/cpp/func/audioop.lin2lin"></a><dt id="audioop.lin2lin">
<tt class="descclassname">audioop.</tt><tt class="descname">lin2lin</tt><big>(</big><em>fragment</em>, <em>width</em>, <em>newwidth</em><big>)</big><a class="headerlink" href="#audioop.lin2lin" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert samples between 1-, 2- and 4-byte formats.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>In some audio formats, such as .WAV files, 16 and 32 bit samples are
signed, but 8 bit samples are unsigned.  So when converting to 8 bit wide
samples for these formats, you need to also add 128 to the result:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">new_frames</span> <span class="o">=</span> <span class="n">audioop</span><span class="o">.</span><span class="n">lin2lin</span><span class="p">(</span><span class="n">frames</span><span class="p">,</span> <span class="n">old_width</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">new_frames</span> <span class="o">=</span> <span class="n">audioop</span><span class="o">.</span><span class="n">bias</span><span class="p">(</span><span class="n">new_frames</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">128</span><span class="p">)</span>
</pre></div>
</div>
<p class="last">The same, in reverse, has to be applied when converting from 8 to 16 or 32
bit width samples.</p>
</div>
</dd></dl>
<dl class="function">
<a name="//apple_ref/cpp/func/audioop.lin2ulaw"></a><dt id="audioop.lin2ulaw">
<tt class="descclassname">audioop.</tt><tt class="descname">lin2ulaw</tt><big>(</big><em>fragment</em>, <em>width</em><big>)</big><a class="headerlink" href="#audioop.lin2ulaw" title="Permalink to this definition">¶</a></dt>
<dd>Convert samples in the audio fragment to u-LAW encoding and return this as a
Python string.  u-LAW is an audio encoding format whereby you get a dynamic
range of about 14 bits using only 8 bit samples.  It is used by the Sun audio
hardware, among others.</dd></dl>
<dl class="function">
<a name="//apple_ref/cpp/func/audioop.minmax"></a><dt id="audioop.minmax">
<tt class="descclassname">audioop.</tt><tt class="descname">minmax</tt><big>(</big><em>fragment</em>, <em>width</em><big>)</big><a class="headerlink" href="#audioop.minmax" title="Permalink to this definition">¶</a></dt>
<dd>Return a tuple consisting of the minimum and maximum values of all samples in
the sound fragment.</dd></dl>
<dl class="function">
<a name="//apple_ref/cpp/func/audioop.max"></a><dt id="audioop.max">
<tt class="descclassname">audioop.</tt><tt class="descname">max</tt><big>(</big><em>fragment</em>, <em>width</em><big>)</big><a class="headerlink" href="#audioop.max" title="Permalink to this definition">¶</a></dt>
<dd>Return the maximum of the <em>absolute value</em> of all samples in a fragment.</dd></dl>
<dl class="function">
<a name="//apple_ref/cpp/func/audioop.maxpp"></a><dt id="audioop.maxpp">
<tt class="descclassname">audioop.</tt><tt class="descname">maxpp</tt><big>(</big><em>fragment</em>, <em>width</em><big>)</big><a class="headerlink" href="#audioop.maxpp" title="Permalink to this definition">¶</a></dt>
<dd>Return the maximum peak-peak value in the sound fragment.</dd></dl>
<dl class="function">
<a name="//apple_ref/cpp/func/audioop.mul"></a><dt id="audioop.mul">
<tt class="descclassname">audioop.</tt><tt class="descname">mul</tt><big>(</big><em>fragment</em>, <em>width</em>, <em>factor</em><big>)</big><a class="headerlink" href="#audioop.mul" title="Permalink to this definition">¶</a></dt>
<dd>Return a fragment that has all samples in the original fragment multiplied by
the floating-point value <em>factor</em>.  Overflow is silently ignored.</dd></dl>
<dl class="function">
<a name="//apple_ref/cpp/func/audioop.ratecv"></a><dt id="audioop.ratecv">
<tt class="descclassname">audioop.</tt><tt class="descname">ratecv</tt><big>(</big><em>fragment</em>, <em>width</em>, <em>nchannels</em>, <em>inrate</em>, <em>outrate</em>, <em>state</em><span class="optional">[</span>, <em>weightA</em><span class="optional">[</span>, <em>weightB</em><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#audioop.ratecv" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the frame rate of the input fragment.</p>
<p><em>state</em> is a tuple containing the state of the converter.  The converter returns
a tuple <tt class="docutils literal"><span class="pre">(newfragment,</span> <span class="pre">newstate)</span></tt>, and <em>newstate</em> should be passed to the next
call of <a class="reference internal" href="#audioop.ratecv" title="audioop.ratecv"><tt class="xref docutils literal"><span class="pre">ratecv()</span></tt></a>.  The initial call should pass <tt class="xref docutils literal"><span class="pre">None</span></tt> as the state.</p>
<p>The <em>weightA</em> and <em>weightB</em> arguments are parameters for a simple digital filter
and default to <tt class="docutils literal"><span class="pre">1</span></tt> and <tt class="docutils literal"><span class="pre">0</span></tt> respectively.</p>
</dd></dl>
<dl class="function">
<a name="//apple_ref/cpp/func/audioop.reverse"></a><dt id="audioop.reverse">
<tt class="descclassname">audioop.</tt><tt class="descname">reverse</tt><big>(</big><em>fragment</em>, <em>width</em><big>)</big><a class="headerlink" href="#audioop.reverse" title="Permalink to this definition">¶</a></dt>
<dd>Reverse the samples in a fragment and returns the modified fragment.</dd></dl>
<dl class="function">
<a name="//apple_ref/cpp/func/audioop.rms"></a><dt id="audioop.rms">
<tt class="descclassname">audioop.</tt><tt class="descname">rms</tt><big>(</big><em>fragment</em>, <em>width</em><big>)</big><a class="headerlink" href="#audioop.rms" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the root-mean-square of the fragment, i.e. <tt class="docutils literal"><span class="pre">sqrt(sum(S_i^2)/n)</span></tt>.</p>
<p>This is a measure of the power in an audio signal.</p>
</dd></dl>
<dl class="function">
<a name="//apple_ref/cpp/func/audioop.tomono"></a><dt id="audioop.tomono">
<tt class="descclassname">audioop.</tt><tt class="descname">tomono</tt><big>(</big><em>fragment</em>, <em>width</em>, <em>lfactor</em>, <em>rfactor</em><big>)</big><a class="headerlink" href="#audioop.tomono" title="Permalink to this definition">¶</a></dt>
<dd>Convert a stereo fragment to a mono fragment.  The left channel is multiplied by
<em>lfactor</em> and the right channel by <em>rfactor</em> before adding the two channels to
give a mono signal.</dd></dl>
<dl class="function">
<a name="//apple_ref/cpp/func/audioop.tostereo"></a><dt id="audioop.tostereo">
<tt class="descclassname">audioop.</tt><tt class="descname">tostereo</tt><big>(</big><em>fragment</em>, <em>width</em>, <em>lfactor</em>, <em>rfactor</em><big>)</big><a class="headerlink" href="#audioop.tostereo" title="Permalink to this definition">¶</a></dt>
<dd>Generate a stereo fragment from a mono fragment.  Each pair of samples in the
stereo fragment are computed from the mono sample, whereby left channel samples
are multiplied by <em>lfactor</em> and right channel samples by <em>rfactor</em>.</dd></dl>
<dl class="function">
<a name="//apple_ref/cpp/func/audioop.ulaw2lin"></a><dt id="audioop.ulaw2lin">
<tt class="descclassname">audioop.</tt><tt class="descname">ulaw2lin</tt><big>(</big><em>fragment</em>, <em>width</em><big>)</big><a class="headerlink" href="#audioop.ulaw2lin" title="Permalink to this definition">¶</a></dt>
<dd>Convert sound fragments in u-LAW encoding to linearly encoded sound fragments.
u-LAW encoding always uses 8 bits samples, so <em>width</em> refers only to the sample
width of the output fragment here.</dd></dl>
<p>Note that operations such as <a class="reference internal" href="#audioop.mul" title="audioop.mul"><tt class="xref docutils literal"><span class="pre">mul()</span></tt></a> or <a class="reference internal" href="#audioop.max" title="audioop.max"><tt class="xref docutils literal"><span class="pre">max()</span></tt></a> make no distinction
between mono and stereo fragments, i.e. all samples are treated equal.  If this
is a problem the stereo fragment should be split into two mono fragments first
and recombined later.  Here is an example of how to do that:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">mul_stereo</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">lfactor</span><span class="p">,</span> <span class="n">rfactor</span><span class="p">):</span>
    <span class="n">lsample</span> <span class="o">=</span> <span class="n">audioop</span><span class="o">.</span><span class="n">tomono</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">rsample</span> <span class="o">=</span> <span class="n">audioop</span><span class="o">.</span><span class="n">tomono</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">lsample</span> <span class="o">=</span> <span class="n">audioop</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">lsample</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">lfactor</span><span class="p">)</span>
    <span class="n">rsample</span> <span class="o">=</span> <span class="n">audioop</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">rsample</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">rfactor</span><span class="p">)</span>
    <span class="n">lsample</span> <span class="o">=</span> <span class="n">audioop</span><span class="o">.</span><span class="n">tostereo</span><span class="p">(</span><span class="n">lsample</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">rsample</span> <span class="o">=</span> <span class="n">audioop</span><span class="o">.</span><span class="n">tostereo</span><span class="p">(</span><span class="n">rsample</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">audioop</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">lsample</span><span class="p">,</span> <span class="n">rsample</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span>
</pre></div>
</div>
<p>If you use the ADPCM coder to build network packets and you want your protocol
to be stateless (i.e. to be able to tolerate packet loss) you should not only
transmit the data but also the state.  Note that you should send the <em>initial</em>
state (the one you passed to <a class="reference internal" href="#audioop.lin2adpcm" title="audioop.lin2adpcm"><tt class="xref docutils literal"><span class="pre">lin2adpcm()</span></tt></a>) along to the decoder, not the
final state (as returned by the coder).  If you want to use
<tt class="xref docutils literal"><span class="pre">struct.struct()</span></tt> to store the state in binary you can code the first
element (the predicted value) in 16 bits and the second (the delta index) in 8.</p>
<p>The ADPCM coders have never been tried against other ADPCM coders, only against
themselves.  It could well be that I misinterpreted the standards in which case
they will not be interoperable with the respective standards.</p>
<p>The <tt class="xref docutils literal"><span class="pre">find*()</span></tt> routines might look a bit funny at first sight. They are
primarily meant to do echo cancellation.  A reasonably fast way to do this is to
pick the most energetic piece of the output sample, locate that in the input
sample and subtract the whole output sample from the input sample:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">echocancel</span><span class="p">(</span><span class="n">outputdata</span><span class="p">,</span> <span class="n">inputdata</span><span class="p">):</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">audioop</span><span class="o">.</span><span class="n">findmax</span><span class="p">(</span><span class="n">outputdata</span><span class="p">,</span> <span class="mi">800</span><span class="p">)</span>    <span class="c"># one tenth second</span>
    <span class="n">out_test</span> <span class="o">=</span> <span class="n">outputdata</span><span class="p">[</span><span class="n">pos</span><span class="o">*</span><span class="mi">2</span><span class="p">:]</span>
    <span class="n">in_test</span> <span class="o">=</span> <span class="n">inputdata</span><span class="p">[</span><span class="n">pos</span><span class="o">*</span><span class="mi">2</span><span class="p">:]</span>
    <span class="n">ipos</span><span class="p">,</span> <span class="n">factor</span> <span class="o">=</span> <span class="n">audioop</span><span class="o">.</span><span class="n">findfit</span><span class="p">(</span><span class="n">in_test</span><span class="p">,</span> <span class="n">out_test</span><span class="p">)</span>
    <span class="c"># Optional (for better cancellation):</span>
    <span class="c"># factor = audioop.findfactor(in_test[ipos*2:ipos*2+len(out_test)],</span>
    <span class="c">#              out_test)</span>
    <span class="n">prefill</span> <span class="o">=</span> <span class="s">'</span><span class="se">\0</span><span class="s">'</span><span class="o">*</span><span class="p">(</span><span class="n">pos</span><span class="o">+</span><span class="n">ipos</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span>
    <span class="n">postfill</span> <span class="o">=</span> <span class="s">'</span><span class="se">\0</span><span class="s">'</span><span class="o">*</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">inputdata</span><span class="p">)</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">prefill</span><span class="p">)</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">outputdata</span><span class="p">))</span>
    <span class="n">outputdata</span> <span class="o">=</span> <span class="n">prefill</span> <span class="o">+</span> <span class="n">audioop</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">outputdata</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="n">factor</span><span class="p">)</span> <span class="o">+</span> <span class="n">postfill</span>
    <span class="k">return</span> <span class="n">audioop</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">inputdata</span><span class="p">,</span> <span class="n">outputdata</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
</div>
<div class="sphinxsidebar">
<div class="sphinxsidebarwrapper">
<h4>Previous topic</h4>
<p class="topless"><a href="mm.html" title="previous chapter">21. Multimedia Services</a></p>
<h4>Next topic</h4>
<p class="topless"><a href="imageop.html" title="next chapter">21.2. <tt class="docutils literal docutils literal"><span class="pre">imageop</span></tt> — Manipulate raw image data</a></p>
<h3>This Page</h3>
<ul class="this-page-menu">
<li><a href="../bugs.html">Report a Bug</a></li>
<li><a href="../_sources/library/audioop.txt" rel="nofollow">Show Source</a></li>
</ul>
<div id="searchbox" style="display: none">
<h3>Quick search</h3>
<form action="../search.html" class="search" method="get">
<input name="q" size="18" type="text"/>
<input type="submit" value="Go"/>
<input name="check_keywords" type="hidden" value="yes"/>
<input name="area" type="hidden" value="default"/>
</form>
<p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
</div>
</div>
<div class="clearer"></div>
</div>
<div class="related">
<h3>Navigation</h3>
<ul>
<li class="right" style="margin-right: 10px">
<a href="../genindex.html" title="General Index">index</a></li>
<li class="right">
<a href="../modindex.html" title="Global Module Index">modules</a> |</li>
<li class="right">
<a href="imageop.html" title="21.2. imageop — Manipulate raw image data">next</a> |</li>
<li class="right">
<a href="mm.html" title="21. Multimedia Services">previous</a> |</li>
<li><img alt="" src="../_static/py.png" style="vertical-align: middle; margin-top: -1px"/></li>
<li><a href="../index.html">Python v2.7.2 documentation</a> »</li>
<li><a href="index.html">The Python Standard Library</a> »</li>
<li><a href="mm.html">21. Multimedia Services</a> »</li>
</ul>
</div>
<div class="footer">
    © <a href="../copyright.html">Copyright</a> 1990-2012, Python Software Foundation.
    <br/>
    The Python Software Foundation is a non-profit corporation.  
    <a href="http://www.python.org/psf/donations/">Please donate.</a>
<br/>
    Last updated on Jan 13, 2012.
    <a href="../bugs.html">Found a bug</a>?
    <br/>
    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.6.7.
    </div>
</body></html>